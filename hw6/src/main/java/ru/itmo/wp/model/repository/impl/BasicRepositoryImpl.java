package ru.itmo.wp.model.repository.impl;

import freemarker.template.Template;
import org.checkerframework.checker.units.qual.A;
import ru.itmo.wp.model.database.DatabaseUtils;
import ru.itmo.wp.model.domain.Event;
import ru.itmo.wp.model.domain.Type;
import ru.itmo.wp.model.exception.RepositoryException;

import javax.servlet.http.HttpServletRequest;
import javax.sql.DataSource;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.*;
import java.util.*;
import java.util.Date;
import java.util.stream.Collectors;
import ru.itmo.wp.model.repository.utils.RepositoryUtils;

public class BasicRepositoryImpl<T> {
    protected final DataSource DATA_SOURCE = DatabaseUtils.getDataSource();
    protected final Class<?> token;

    public BasicRepositoryImpl(Class<?> token){
        this.token = token;
    }

    protected void baseSave(T value, Map<String, String> params, Map<String, Class<?>> objectParameters){
        try (Connection connection = DATA_SOURCE.getConnection()) {
            String rawStatement = "INSERT INTO `" + token.getSimpleName() + "` (";
            rawStatement += params.keySet().stream().map(v -> "`" + v + "`").collect(Collectors.joining(","));
            rawStatement += ", `creationTime`) VALUES (";
            for (int i = 0; i < params.size(); i++) {
                rawStatement += "?, ";
            }
            rawStatement += "NOW())";
            try (PreparedStatement statement = connection.prepareStatement(
                    rawStatement,//"INSERT INTO `Event` (`userId`, `type`, `creationTime`) VALUES (?, ?, NOW())",
                    Statement.RETURN_GENERATED_KEYS
            )) {
                int ind = 1;
                for (String key : params.keySet()) {
                    statement.setString(ind, params.get(key));
                    ind += 1;
                }
                if (statement.executeUpdate() != 1) {
                    throw new RepositoryException("Can't save Event.");
                } else {
                    ResultSet generatedKeys = statement.getGeneratedKeys();
                    if (generatedKeys.next()) {
                        long id = generatedKeys.getLong("insert_id");
                        Date creationTime = (Date) RepositoryUtils.getGetter(token, "creationTime").invoke(baseSingleFind(Map.of("id", String.valueOf(id)), objectParameters));
                        RepositoryUtils.getSetter(token, "id", long.class).invoke(value, id);
                        RepositoryUtils.getSetter(token, "creationTime", Date.class).invoke(value, creationTime);
                        //RepositoryUtils.getSetter(token, "creationTime").invoke(value, RepositoryUtils.getGetter(token, "creationTime").invoke(baseFind(id, parameters)));
                    } else {
                        throw new RepositoryException("Can't save User [no autogenerated fields].");
                    }
                }
            } catch (SQLException | NoSuchMethodException | InvocationTargetException | IllegalAccessException ex) {
                throw new RuntimeException(ex);
            }
        } catch (SQLException e) {
            throw new RepositoryException("Can't save User.", e);
        }
    }

    protected List<T> baseFind(Map<String, String> params, Map<String, Class<?>> objectParams) {
        List<T> result = new ArrayList<>();
        try (Connection connection = DATA_SOURCE.getConnection()) {
            String rawStatement = "SELECT * FROM " + token.getSimpleName();
            if(params.size() > 0) {
                String paramString = params.keySet().stream().map(v -> v + "=?").collect(Collectors.joining(" AND "));
                rawStatement += " WHERE " + paramString;
            }
            try (PreparedStatement statement = connection.prepareStatement(rawStatement)) {
                int index = 1;
                for(String val : params.values()){
                    statement.setString(index, val);
                    index += 1;
                }
                try (ResultSet resultSet = statement.executeQuery()) {
                    T value;
                    while ((value = parse(statement.getMetaData(), resultSet, objectParams)) != null) {
                        result.add(value);
                    }
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException("Can't find Event.", e);
        }
        return result;
    }

    protected T baseSingleFind(Map<String, String> params, Map<String, Class<?>> objectParams){
        List<T> result = baseFind(params, objectParams);
        if(result.size() == 0){
            return null;
        }
        return result.get(0);
    }

    protected T parse(ResultSetMetaData metaData, ResultSet resultSet, Map<String, Class<?>> params) throws SQLException {
        if (!resultSet.next()) {
            return null;
        }
        Map<String, Class<?>> fields = new HashMap<>(params);
        fields.put("id", long.class);
        fields.put("creationTime", Date.class);
        try {
            T result = (T) token.getDeclaredConstructor().newInstance();

            for (int i = 1; i <= metaData.getColumnCount(); i++) {
                String name = metaData.getColumnLabel(i);
                if (fields.containsKey(name)) {
                    RepositoryUtils.getSetter(token, name, fields.get(name)).invoke(result,
                            RepositoryUtils.getResultGetter(fields.get(name).getSimpleName()).invoke(resultSet, i));
                }
            }
            return result;
        }catch(NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e){
            throw new RuntimeException(e);
        }


    }
}
